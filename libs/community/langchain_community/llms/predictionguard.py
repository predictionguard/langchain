import logging
from typing import Any, Dict, List, Optional

from langchain_core.callbacks import CallbackManagerForLLMRun
from langchain_core.language_models.llms import LLM
from langchain_core.utils import get_from_dict_or_env, pre_init
from pydantic import ConfigDict

from langchain_community.llms.utils import enforce_stop_tokens

logger = logging.getLogger(__name__)


class PredictionGuard(LLM):
    """Prediction Guard large language models.

    To use, you should have the ``predictionguard`` python package installed, and the
    environment variable ``PREDICTIONGUARD_API_KEY`` set with your api_key, or pass
    it as a named parameter to the constructor.

    Example:
        .. code-block:: python

            pgllm = PredictionGuard(model="Hermes-2-Pro-Llama-3-8B",
                                    api_key="my-api-key"
                                    )
    """

    client: Any  #: :meta private:
    model: Optional[str] = "Hermes-2-Pro-Llama-3-8B"
    """Model name to use."""

    input: Optional[Dict[str, Any]] = None
    """The input check to run over the prompt before sending to the LLM."""

    output: Optional[Dict[str, Any]] = None
    """The output check to run the LLM output against."""

    max_tokens: int = 256
    """Denotes the number of tokens to predict per generation."""

    temperature: float = 0.75
    """A non-negative float that tunes the degree of randomness in generation."""

    top_p: float = 0.1
    """A non-negative float that controls the diversity of the generated tokens."""

    api_key: Optional[str] = None
    """Your Prediction Guard api_key."""

    stop: Optional[List[str]] = None

    model_config = ConfigDict(
        extra="forbid",
    )

    @pre_init
    def validate_environment(cls, values: Dict) -> Dict:
        """Validate that the api_key and python package exists in environment."""
        api_key = get_from_dict_or_env(values, "api_key", "PREDICTIONGUARD_API_KEY")
        try:
            from predictionguard import PredictionGuard

            client = PredictionGuard(
                api_key=api_key
            )

            values["client"] = client
        except ImportError:
            raise ImportError(
                "Could not import predictionguard python package. "
                "Please install it with `pip install predictionguard`."
            )
        return values

    @property
    def _default_params(self) -> Dict[str, Any]:
        """Get the default parameters for calling the Prediction Guard API."""
        return {
            "max_tokens": self.max_tokens,
            "temperature": self.temperature,
            "top_p": self.top_p
        }

    @property
    def _identifying_params(self) -> Dict[str, Any]:
        """Get the identifying parameters."""
        return {**{"model": self.model}, **self._default_params}

    @property
    def _llm_type(self) -> str:
        """Return type of llm."""
        return "predictionguard"

    def _call(
        self,
        prompt: str,
        stop: Optional[List[str]] = None,
        run_manager: Optional[CallbackManagerForLLMRun] = None,
        **kwargs: Any,
    ) -> str:
        """Call out to Prediction Guard's model API.
        Args:
            prompt: The prompt to pass into the model.
        Returns:
            The string generated by the model.
        Example:
            .. code-block:: python
                response = pgllm.invoke("Tell me a joke.")
        """
        from predictionguard import PredictionGuard

        client = PredictionGuard()

        params = self._default_params
        if self.stop is not None and stop is not None:
            raise ValueError("`stop` found in both the input and default params.")
        elif self.stop is not None:
            params["stop_sequences"] = self.stop
        else:
            params["stop_sequences"] = stop

        response = client.completions.create(
            model=self.model,
            prompt=prompt,
            input=self.input,
            output=self.output,
            temperature=params["temperature"],
            max_tokens=params["max_tokens"],
            top_p=params["top_p"]
            **kwargs,
        )
        text = response["choices"][0]["text"]

        # If stop tokens are provided, Prediction Guard's endpoint returns them.
        # In order to make this consistent with other endpoints, we strip them.
        if stop is not None or self.stop is not None:
            text = enforce_stop_tokens(text, params["stop_sequences"])

        return text
